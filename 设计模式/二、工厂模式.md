# 工厂模式

## 简单工厂

- 定义：

  > 简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个函数负责创建其他类的实例，被创建的实例通常都具有共同的父类(即同一种类型的对象)

```js
// 篮球基类
function Basketball () {
	this.intro = '篮球盛行于美国'
}
Baseketball.prototype.getMember = function () {
  console.log('每个队伍需要5名队员')
}
    
// 足球基类
function Football () {
  this.intro = '足球在世界范围内很流行'
}
Football.prototype.getMember = function () {
  console.log('每个队伍需要11名队员')
}
// 运动工厂
function SportsFactory (name) {
  switch (name){
    case 'NBA':
      return new Basketball()
      break
    case: 'worldCup':
      return new Football()
     	break
  }
}
// 使用简单工厂创建实例对象
const footnall = SportsFactory('worldCup')
```

- 缺点:
  每新增一个类都需要修改两个地方，如果类越来越多，则这个工厂函数会变成超级函数，不容易维护，所以简单工厂模式只适合少量的类，并且逻辑比较简单的情况

## 工厂方法模式

- 定义:

  > 工厂模式中，工厂父类负责定义创建产品对象的公告接口，而工厂子类则负责生产具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例哪一个具体的产品类 (注: JavaScript没有像传统创建抽象类那样的方式轻易创建抽象类，所以在JavaScript中实现工厂方法模式我们只需要参考它的核心思想即可)

- 安全模式类

  > 安全模式可以屏蔽错误使用类时造成的错误

  ```js
  function Demo () {
    if (!(this instanceof Demo)) {
      return new Demo()
    }
  }
  const demo = Demo()
  ```

```js
// 安全模式创建的工厂类
function Factory (type, content) {
  if (this instanceof Factory) {
    const s = new this[type](content)
    return s
  } else {
    return new Factory(type, content)
  }
}
// 工厂原型中设置创建所有类型数据对象的基类
Factory.prototype = {
  Java (content) {
    // ......
  }
  JavaScript (content) {
    // ......
  }
}
```

这样我们以后如果想添加其他类时，只需要写在Factory这个工厂类的原型里面就可以了

## 抽象工厂模式

- 定义:

```js
// 抽象工厂方法
function VehicleFactory (subType, superType) {
  // 判断抽象工厂中是否有该抽象类
  if (typeof VehicleFactory[subType] === 'function') {
    // 缓存类
    function F(){}
    // 继承父类属性和方法
    F.prototype = new VehicleFactory[superType] ()
    // 将子类constructor指向子类
    subType.constructor = subType
    // 子类原型继承父类
    subType.prototype = new F()
  } else {
    // 不存在该抽象类抛出错误
    throw new Error('未创建该抽象类')
  }
}
// 小汽车抽象类
VehicleFactory.Car = function () {
  this.type = 'Car'
}
VehicleFactory.Car.prototype = {
  getPrice () {
    return new Error('抽象方法不能调用')
  }
  getSpeed () {
    return new Error('抽象方法不能调用')
  }
}
// 实现
// 宝马汽车子类
function BWM (price, speed) {
  this.price = price
  this.speed = speed
}
// 抽象工厂实现对Car抽象类的继承
VehicleFactory(BWM, 'Car')
BWM.prototype.getPrice = function () {// ...}
BWM.prototype.getSpeed = function () {// ...}
```

